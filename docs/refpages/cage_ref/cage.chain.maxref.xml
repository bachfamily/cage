<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<?xml-stylesheet href="./_c74_ref.xsl" type="text/xsl"?>

<!--This file has been automatically generated by Doctor Max. DO NOT EDIT THIS FILE DIRECTLY.-->

<c74object name="cage.chain" module="cage" kind="patcher">

	<digest>
		One-dimensional cellular automata and L-systems
	</digest>

	<description>
		Rewrites a sequence of symbols according to some
		formal grammar rules.
	</description>

	<!--METADATA-->
	<metadatalist>
		<metadata name="author">cageproject</metadata>
		<metadata name="tag">cage</metadata>
		<metadata name="tag">cage automata</metadata>
	</metadatalist>

	<!--INLETS-->
	<inletlist>
		<inlet id="0" type="INLET_TYPE">
			<digest>
				Number of steps
			</digest>
			<description>
			</description>
		</inlet>
		<inlet id="1" type="INLET_TYPE">
			<digest>
				Starting sequence
			</digest>
			<description>
			</description>
		</inlet>
		<inlet id="2" type="INLET_TYPE">
			<digest>
				Rules
			</digest>
			<description>
				See the <m>llll</m> method.
			</description>
		</inlet>
		<inlet id="3" type="INLET_TYPE">
			<digest>
				Lambda inlet
			</digest>
			<description>
				A lambda inlet is an inlet receiving the answer from a test or modification performed on elements sent out the lambda outlets. <br />
				In this case, the answer is expected to be a modification of the elements which had been sent out:
				the element output via the lambda outlet can be customly modified and then plugged in into this lambda inlet:
				such modification will be accounted for by the algorithm. <br />
				The lambda inlet also accepts the result in llll form, so you can sometimes avoid the explicit @out t. <br />
				It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
				<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
				<br /> <br />
			</description>
		</inlet>
	</inletlist>

	<!--OUTLETS-->
	<outletlist>
		<outlet id="0" type="INLET_TYPE">
			<digest>
				Rewritten sequences
			</digest>
			<description>
			</description>
		</outlet>
		<outlet id="1" type="INLET_TYPE">
			<digest>
				Lambda outlet
			</digest>
			<description>
				Outputs the chunk of elements for custom rules.
				A lambda outlet is an outlet outputting an element on which some test or modification must be performed.
				The result of the test or modification is then expected in a lambda inlet. <br />
				In this case, the elements output from the lambda outlet may be customly modified, so that such modification will be taken into
				account by the algorithm. To modify each element, just use patching and then plug into the lambda inlet the
				modified version of the element. <br />
				It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
				<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
				<br /> <br />
			</description>
		</outlet>
		<outlet id="2" type="INLET_TYPE">
			<digest>
				Lambda outlet: iteration number
			</digest>
			<description>
				Before each iteration, the iteration number is output
				via this outlet, starting from 1. This number is reset whenever an integer comes
				in the first inlet, or whenever the starting sequence is reset.
			</description>
		</outlet>
	</outletlist>

	<!--ARGUMENTS-->
	<objarglist>
		<objarg name="order" optional="1" type="int">
			<digest>
				Order
			</digest>
			<description>
				The optional argument sets the order (i.e. the length of the overlapping chunks
				of the original sequence to be output). The order only needs to be set when using
				lambda loops to define rules. If rules are defined via the third inlet, order is automatically
				set to the length of the original chunks inside the rules (see <m>llll</m> method).
			</description>
		</objarg>
	</objarglist>

	<!--MESSAGES-->
	<methodlist>
		<method name="bang">
			<arglist />
			<digest>
				Output next rewriting step
			</digest>
			<description>
				A <m>bang</m> in the first inlet outputs the next rewriting step through the left outlet,
				and updates the internal memory (so that, for instance, if an <m>int</m> comes through the first inlet,
				the initial sequence will then be the last output one).
			</description>
		</method>
		<method name="int">
			<arglist />
			<digest>
				Output rewriting steps
			</digest>
			<description>
				An integer number <m>n</m> in the first inlet outputs the first <m>n</m> steps
				of the rewriting process. First step corresponds to the initial sequence ("axiom").
				Then each step is calculated as explained in the <m>llll</m> method. All steps are then
				collected, each one wrapped with a level of parentheses, and then the overall list is output
				through the left outlet.
			</description>
		</method>
		<method name="llll">
			<arglist />
			<digest>
				Function depends on inlet
			</digest>
			<description>
				An <m>llll</m> in the second inlet is the starting
				sequence of symbols (or "axiom") for the rewriting system. <br />
				An <m>llll</m> in third inlet sets the rules for the rewriting.
				Such <m>llll</m> must be in the form: <b><m>RULE1</m> <m>RULE2</m>...</b>,
				where each <m>RULE</m> is an llll of the form <b>((<m>ORIG_SEQ</m>) <m>MODIF_SEQ</m>)</b>,
				where in turns <m>ORIG_SEQ</m> are the chunk of elements to be matched and
				<m>MODIF_SEQ</m> is the element(s) to be substituted. <br />
				For instance, with rules <b>((a a) a) ((a b) b) ((b a) b) ((b b) a)</b>,
				with default padding and with right pad alignment, the sequence <b>a a b a</b> will be converted into
				<b>a b b a</b>. To clarify the steps, given the input rules, the order is detected to be 2,
				then the elements of the original sequence are taken as couples <b>a a</b>, <b>a b</b>,
				<b>b a</b>, <b>a a</b>, where the last couple has been obtained by padding the last element.
				Each of these couples is then changed according to the rules, and the resulting elements
				are collected. <br />
				All <m>ORIG_SEQ</m> in the rule llll must have the same length, corresponding to the
				order of the rewriting system.
				On the other hand <m>MODIF_SEQ</m> lllls can have variable length, producing variable length
				output sequences.
				If no rule is given for a certain chunk, the original reference element is kept (also see
				<m>align</m> attribute); for instance, if alignment is right, and no rule were
				given in the above example for <b>a b</b>, then <b>a</b> would be kept as result. <br />
				An <m>llll</m> in fourth (lambda) inlet is considered the modified version of the symbols output
				through the lambda outlet. If a lambda loop is present, indeed, the rules are completely ignored.
				In this case, order should always be explicitly defined via the <m>order</m>
				attribute. Chunks of the original llll are output one by one through the lambda outlet,
				each having as length the defined order, and the user should provide the modification result
				for each chunk by patching, and re-inject it in the lambda inlet.
				A lambda inlet is an inlet receiving the answer from a test or modification performed on elements sent out the lambda outlets. <br />
				In this case, the answer is expected to be a modification of the elements which had been sent out:
				the element output via the lambda outlet can be customly modified and then plugged in into this lambda inlet:
				such modification will be accounted for by the algorithm. <br />
				The lambda inlet also accepts the result in llll form, so you can sometimes avoid the explicit @out t. <br />
				It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
				<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
				<br /> <br />
			</description>
		</method>
	</methodlist>

	<!--ATTRIBUTES-->
	<attributelist>
		<attribute name="align" get="1" set="1" type="int" size="1">
			<digest>
				Padding Alignment
			</digest>
			<description>
				Sets the alignment for the padding, when the <m>order</m>
				is greater than 1. <br />
				- If alignment is <b>Left</b>, the reference element for each
				chunk will be the leftmos one. For instance, if order is 2 and <m>pad</m> is
				the default one, the sequence <b>a b c</b> will be output in the following chunks:
				<b>a a</b>, <b>a b</b> and <b>b c</b>, each having as reference element the last one. <br />
				- If alignment is <b>Center</b> (default), the padding is done both at left and at right.
				and the reference element for each
				chunk will be the center one. For instance, if order is 3 and <m>pad</m> is
				the default one, the sequence <b>a b c d</b> will be output in the following chunks:
				<b>a a b</b>, <b>a b c</b>, <b>b c d</b> and <b>c d d</b>, each having as reference
				element the middle one.
				If chunks have even length, the center element will be rounded to the left (thus the number of padded
				elements will be bigger at right). <br />
				- If alignment is <b>Right</b>, the padding will be done at right.
				For instance, if order is 2 and <m>pad</m> is
				the default one, the sequence <b>a b c</b> will be output in the following chunks:
				<b>a b</b>, <b>b c</b> and <b>c c</b>, each having as reference element the first one. <br />
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Padding Alignment" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="enumindex" />
			</attributelist>
		</attribute>
		<attribute name="maxdepth" get="1" set="1" type="int" size="1">
			<digest>
				Maximum Depth
			</digest>
			<description>
				Sets the depth until which rewriting should be performed. Rules indeed can create
				levels of parentheses. The default value for this attribute is 0 (rewriting is only performed for the root llll),
				however meaningful values for such attribute are typically negative ones: for instance, -2 will force the rewriting
				for all lllls on the deepest level of depth.
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Maximum Depth" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="order" get="1" set="1" type="int" size="1">
			<digest>
				Order
			</digest>
			<description>
				Sets the order (i.e. the length of the overlapping chunks
				of the original sequence to be output). The order only needs to be set when using
				lambda loops to define rules. If rules are defined via the third inlet, order is automatically
				set to the length of the original chunks inside the rules (see <m>llll</m> method).
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Order" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="out" get="1" set="1" type="symbol" size="1">
			<digest>
				Outlet Types
			</digest>
			<description>
			</description>
			<attributelist>
				<attribute name="category" get="1" set="1" type="symbol" size="1" value="Behavior" />
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Outlet Types" />
				<attribute name="save" get="1" set="1" type="int" size="1" value="1" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
		<attribute name="pad" get="1" set="1" type="llll" size="1">
			<digest>
				Padding Element
			</digest>
			<description>
				Sets the padding element of the initial and end chunks, when the <m>order</m>
				is greater than 1. If this attribute is <b>auto</b> (default), then the starting and
				ending element are used to pad, respectively, the starting and ending chunks. If this attribute
				is <b>null</b>, no pad is performed.
				If a single element is given (llll of length 1), such element is used to pad both the
				starting and the ending chunks. If two elements are given (llll of length 2), the first
				element is used to pad the starting chunks, while the second one is used to pad the
				ending chunks.
			</description>
			<attributelist>
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Padding Element" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
	</attributelist>

	<!--DISCUSSION-->
	<discussion>
		Rules can be defined either via the third inlet (see
		<m>llll</m> method) or via a lambda loop.
	</discussion>

	<!--SEEALSO-->
	<seealsolist>
		<seealso name="cage.life" />
	</seealsolist>

	<misc name = "Input">
		<entry name ="Inlet 1 (int)">
			<description>
				Number of steps.
			</description>
		</entry>
		<entry name ="Inlet 2 (llll)">
			<description>
				Starting sequence.
			</description>
		</entry>
		<entry name ="Inlet 3 (llll)">
			<description>
				Rules.
				See the <m>llll</m> method.
			</description>
		</entry>
		<entry name ="Inlet 4 (llll)">
			<description>
				Lambda inlet.
				A lambda inlet is an inlet receiving the answer from a test or modification performed on elements sent out the lambda outlets. <br />
				In this case, the answer is expected to be a modification of the elements which had been sent out:
				the element output via the lambda outlet can be customly modified and then plugged in into this lambda inlet:
				such modification will be accounted for by the algorithm. <br />
				The lambda inlet also accepts the result in llll form, so you can sometimes avoid the explicit @out t. <br />
				It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
				<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
				<br /> <br />
			</description>
		</entry>
	</misc>

	<misc name = "Output">
		<entry name ="Outlet 1 (llll)">
			<description>
				Rewritten sequences.
			</description>
		</entry>
		<entry name ="Outlet 2 (llll)">
			<description>
				Lambda outlet.
				Outputs the chunk of elements for custom rules.
				A lambda outlet is an outlet outputting an element on which some test or modification must be performed.
				The result of the test or modification is then expected in a lambda inlet. <br />
				In this case, the elements output from the lambda outlet may be customly modified, so that such modification will be taken into
				account by the algorithm. To modify each element, just use patching and then plug into the lambda inlet the
				modified version of the element. <br />
				It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
				<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
				<br /> <br />
			</description>
		</entry>
		<entry name ="Outlet 3 (llll)">
			<description>
				Lambda outlet: iteration number.
				Before each iteration, the iteration number is output
				via this outlet, starting from 1. This number is reset whenever an integer comes
				in the first inlet, or whenever the starting sequence is reset.
			</description>
		</entry>
	</misc>

	<misc name = "Discussion">
		<entry name ="More details">
			<description>
		Rules can be defined either via the third inlet (see
		<m>llll</m> method) or via a lambda loop.
			</description>
		</entry>
		<entry name ="Keywords">
			<description>
cellular automata, chain, L-system, rewrite, write, sequence, vector, rule, system, lambda loop.
			</description>
		</entry>
	</misc>

</c74object>