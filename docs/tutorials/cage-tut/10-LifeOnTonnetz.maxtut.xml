<?xml version='1.0' encoding='UTF-8'?>

<?xml-stylesheet href="./_c74_tut.xsl" type="text/xsl"?>

<chapter name="cage Tutorial 10: Life On Tonnetz">

<openfile name="Life On Tonnetz" patch="LifeOnTonnetz.maxpat"/>


<indexinfo category="Automata" title="Life On Tonnetz">Automata</indexinfo>

<header>Tutorial 10: LifeOnTonnetz</header>

<body>In this tutorial, we will build a 2D cellular automata whose cells will coincide with the vertex of a tonnetz. You might want to follow the L-systems tutorial (covering the 1D case) before approaching this subject: such tutorial will also explain some intricacies (as padding), which also apply in the 2D case.</body>

<body><openpatchlink>Open the tutorial patch</openpatchlink></body>


<subhead>The tonnetz</subhead>

<body>The tonnetz is 2D pitch space having as center a certain fixed note, and generated by two intervals (along two given directions, usually forming a 60 degrees angle, so to have an hexagonal lattice). The standard choice for the base intervals is: major fifth and major third. In the bach library, the tonnetz is implemented in the <o>bach.tonnetz</o> graphic editor.</body>

<body>The hexagonal lattice generated by the tonnetz should not scare: one can easily identify each cell via 2 coordinates: "how much" did we go to the right (from the center), and "how much" did we go along the 60 degrees top-right direction (from the center). For instance, if the center is the C4 (as in our tutorial patch), the G4 will have coordinates (1, 0), while the D#5 will have coordinates (1, 2), since it is obtained by going one step to the right (getting to G4) and then 2 steps along the 60 degrees top-right diagonal. 
In other words, the hexagonal lattice can be easily seen as a "skewed" square matrix.</body>

<body><o>bach.tonnetz</o> accepts in its inlets the information about the points which should be selected (active). We can thus input any configuration to be displayed by selecting elements via one of the following ways: midicents (first inlet), pitch classes (second inlet), diatonic intervals (third inlet), or coordinates (exactly as we have seen: fourth inlet).</body>

<body>All the elements of such configuration will also be properly played (echoed) from the "Queries and Notifications" outlet, provided that we set the "echo" attribute to 1. If we enter the new elements preceded by a "replace" symbol, all the needed note-offs will also be output from the outlet.</body>

<body>Open the tutorial patch. The "echo" information output from the "Queries and Notifications" outlet has the form: <b>echo <m>midicents</m> <m>pitch-class</m> <m>diatonic_interval</m> <m>coordinates</m> <m>velocity</m></b>. we only need to take midicents and velocity, and divide midicents by 100 and feed them to the <o>noteout</o> object, in order to properly have a play mechanism. This is exactly what we do in the "play" section of the tutorial patch.</body>

<subhead>The Game of Life</subhead>

<body>2D cellular automata are, in their simplest form, rule-based mechanism which takes a matrix of elements (say, a matrix whose elements are 0's or 1's), and determines how this matrix "evolves" to the next configuration, i.e. yields another matrix having the same size, with a new configuration of 0's and 1's. The module in cage which implements this mechanism is <o>cage.life</o>.</body>

<body>Among all 2D cellular automata, the most famous one is probably the so-called Game of Life (or GoL), an extremely simple model invented by John Conway around 1970, which can in turn produce extremely complex and interesting patterns.</body>

<body>The Game Of Life is usually played on a square matrix. Each cell has thus 8 neighbors (top-left, top-center, top-right, middle-right, bottom-right, bottom-center, bottom-left, middle-left), and can only have two states: either alive (1) or dead (0). The rules for the automata determines how, given a configuration, we can get obtain next one (the "next generation). Such rules are as simple as the following ones: A) if a cell is alive, it stays alive if and only if it has exactly 2 or 3 living neighbors; B) if a cell is dead, it can come back to life if and only if it has exactly 3 living neighbors. These rules mimics the behavior of living systems: if a cell has too many neighbors it will die by overcrowding, if a cell has too few neighbors it will die for underpopulation; if a dead cell has exactly three neighbors it will come to life, as by reproduction.</body>

<subhead>The <o>cage.life</o> module</subhead>

<body><o>cage.life</o> implements by default the rules of the Game of Life. Such rules can be changed and made custom, provided that you set them via the lambda loop. We will not enter into this mechanism here, but you can give a look at the <o>cage.life</o> help file to understand how this works.</body>

<body><o>cage.life</o> accepts the "current state" (the whole matrix) in the middle inlet, and then bangs in its left inlet to have this matrix "evolve". The matrix for each generation is output through the left inlet.</body>

<subhead>Tonnetz and Game of Life</subhead>

<body>This simple mechanism is an abstract mechanism which can be applied to any matrix-like 2D configuration. The tonnetz coordinates are, as we have seen, coordinate of a matrix. So we can easily start from a random matrix of 0's and 1's, display it on the tonnetz, and see how it evolves.</body>

<body>To generate a random matrix, we can use <o>bach.mrandom</o>, introducing the number of rows and columns of the matrix as arguments. In our case, we start with a 10x10 matrix, which represents our "world", but we can change the world size via the numberbox. Click on the red button to generate a random matrix: this will be set as current state of <o>cage.life</o>. </body>

<body>Now bang the green button: <o>cage.life</o> will first of all output the starting configuration, as a matrix of 0's and 1's (at the first bang this will thus coincide exactly with the matrix obtained from <o>bach.mrandom</o>, unless you change the <m>repeatfirst</m> attribute). All we have to do is display the cells containing 1's on the tonnetz. However, <o>bach.tonnetz</o> doesn't accept a matrix as input, rather a sequence of coordinates (via the fourth inlet). We need thus to collect the coordinates of all elements in the matrix which are equal to 1. This is what we do in the subpatch "matric2ptcoordinates": we iterate on the elements of the matrix, and if they are one we collect their coordinates in the form <b>(x y) (x y)...</b></body>

<body>In order to get the matrix centered with respect to the (0, 0) tonnetz center, we shift all coordinates of half of the world size. For instance, a coordinate of (3, 1) will now be (3-5, 1-5) = (-2, -4). In this way, we have our world always centered with respect to the tonnetz center, and not confined in the right-top region.</body>


<subhead>Evolution!</subhead>

<body>We are now ready to bang repeatedly the green button, or even to turn on the yellow toggle driving the <o>metro</o> object: at each step, <o>cage.life</o> will output a new generation, which will be converted into coordinates and fed to <o>bach.tonnetz</o>. Notice that if such generation is empty, <o>bach.filternull</o> will output a bang from the right outlet, and we will simply send a "replace" message, to have <o>bach.tonnetz</o> output the necessary note-offs.</body>

<body>Once your pattern has come to a dead-end, you can restart by clicking on the red button (thus setting a new random start matrix. Also try to increase or reduce the world size.</body>


<subhead>What's outside the world?</subhead>

<body>Some intricacies of (finite) cellular automata involve the determination of the behavior at the borders. Please follow the L-systems tutorial to understand such mechanism: the 2D case makes no exception to this rule, and it is important to state what happens at the "border of our world", especially because our world is rather small (10x10 = 100 points).</body>

<body>The problem is the following one: each cell is substituted depending on its 8 neighbors; however, border cells don't have all such neighbors. How do we consider the neighbors that "do not exist"? The ones that lie "outside our world"? The default approach for <o>cage.life</o> is to mirror outside the border the cells that are inside it. Although this might lead to more interesting and lasting patterns, this is not the most clear framework: let us state explicitly, with "@pad 0", that we want any cell outside the world to be considered as a "dead" cell, period. You might want to test the difference with "@pad 1", considering any cell outside the world as a "living" cell. </body>


<subhead>Conclusion</subhead>

<body>We have built a simple 2D cellular automata which acts on the notes of a tonnetz lattice. This mechanism can be of course improved by changing the rules (e.g. instead of using the Conway's square matrix rules, one might want to use hexagonal-based rules) or by adding interactivity (e.g. users can add or remove notes via a midi keyboard for any configuration state). Finally, you can modify the tonnetz attributes to change the generating intervals, or to have it purely diatonic.</body>

<seealsolist>
<seealso name="cage.life"></seealso>
<seealso name="bach.mrandom"></seealso>
<seealso name="L-systems"></seealso>
</seealsolist>

</chapter>
