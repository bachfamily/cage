<?xml version='1.0' encoding='UTF-8'?>

<?xml-stylesheet href="./_c74_tut.xsl" type="text/xsl"?>

<chapter name="cage Tutorial 11: Earthworms">

<openfile name="Earthworms" patch="Earthworms.maxpat"/>


<indexinfo category="Automata" title="Earthworms">Automata</indexinfo>

<header>Tutorial 11: Earthworms</header>

<body>In this tutorial, we will study an interesting example built around the <o>cage.lumbricus</o> abstraction, and suggested by composer Michael Jarrell. As we shall see, the goal of the patch is constructing melodic sequences according to certain specific rules.</body>


<body><openpatchlink>Open the tutorial patch</openpatchlink></body>

<subhead>The earthworm</subhead>

<body>Constraint- and rule-based approaches to problems are fascinating, because they reflect the way we think. If I have to do a car trip, the first thing I want to know is where I'm going and how much time I have, rather than follow a dumb sequence of petty instruction such as "turn left at the third traffic light" or "go straight 152.36 km". This is quite the opposite of what usually happens with computer programming: we all have been taught that computers are stupid and they need to be painstakingly told every single detail about how we want them to do stuff for us. Indeed, some very elegant programming paradigms exist to help us express problems in more intelligent ways, such as "find a result within this set of rules", or "let this structure evolve for some time according to these rules": the <o>bach.constraints</o> and <o>cage.chain</o> modules exemplify some of them, the former doing constraints-based searches, the latter building chains of elements through generative grammars. Unfortunately, life is not always elegant. For example, composers are used to think in terms of constraints, but they also often need to build sequences of things happening in time. They often need something in between the two approaches. <o>cage.lumbricus</o> is a tentative solution to this hybrid category of problems.</body>

<body>To explain the idea behind <o>cage.lumbricus</o>, let's start with a slightly simplified version. We want to build a sequence of a predetermined length, composed of elements belonging to a predefined set - let's call this set "the domain". We want to build our sequence one element after another: that is, we will chose which element to put at the n-th place of the sequence only after the first n-1 elements have been defined. For each position of the sequence, we want to be able to determine whether a given element is a good candidate or not, by taking into account its place in the sequence and/or the elements that precede it: for example, we want to be able to say that element A can't appear after element B, or that element C can appear only after the sequence D D D, or that element E can only appear at odd-numbered positions, such as the first, the third, the fifth. We want the object to backtrack if it comes to a dead end. We want to be able to define a quality score for each possible match: for example, both C and D can appear after a D, but whenever possible C should be preferred; the score should be assigned case by case, so as to make it possible to insert  randomness in the process. We want to define an indicative overall probability for each element to appear: for example, we want to say that about 30% of the elements of the final sequence should be A, 25% B, 15% C, 10% D, 20% E; these probabilities are called weights. That's quite a lot of requests, and this is the simplified version! Indeed, <o>cage.lombricus</o> implements two more features: first, the concept of "family of elements", which is relevant for both the assignment rules (the choice of a given element might involve knowing its family) and the weight (which is actually given by family, rather than by element); second, the fact that the element itself may be inserted in the sequence as it is, or after some modification - this is the case in the example we are about to discuss.</body>

<body>So, how is all this implemented in <o>cage.lumbricus</o>? We can give directly to the abstraction the length of the inserted sequence, the domains subdivided in families, the weight of each family and one or more possible starting elements. As for the rules, they must be expressed through a lambda loop: at each step of the evaluation, the rightmost outlet of <o>cage.lumbricus</o> outputs a series of lllls, each containing a proposed element, the index of the family that contains it and all the sequence built so far. With these elements, the rules can be evaluated: therefore, the rightmost inlet expects in return a score assigned to the proposed element, and the data that should actually be inserted in the sequence (and which may or may not coincide with the proposed element). The score can be any value: a higher score indicates a stronger preference given to that element; the only caveat is that a score of 0 means that the element is rejected for that position in the chain, regardless of the score of the others. The score that is returned to the lambda outlet will then be combined with the weight in order to try to keep the probabilities as close as possible to the desired ones.</body>




<subhead>The problem</subhead>

<body>And now, here's our problem: we want to build a melodic sequence solely composed of certain notes and certain intervallic cells; optionally, each sequence can be associated to its inversion, retrograde or permutations (we will generically call these operations "transformations"); each element, along with its transformations, has a weight; finally, we want to be able to define an overall melodic profile of the sequence.</body>

<body>How do implement all this with <o>cage.lumbricus</o>? For a start, each  intervallic cell, together with its transformations, will be a family of elements (the elements themselves being the original cell and the desired transformations, one by one). By the way, this means that at each step we shall not insert in the sequence the original element, but rather the notes defined by the given intervallic sequence with respect to the last note of the sequence built so far: for example, if the chosen element is <b>400 -300</b>, that is an ascending major third and a descending minor third, and the last note in the sequence is 6500, that is F4, the new data introduced in the sequence shall be an 6900 6700, that is A4 F#4. In this way, the sequence we'll build will actually be composed of notes, although the elements are defined as intervals: and indeed, the starting element will be a note as well. Then there are the rules, and the other data. Here we need to make a distinction: the intervals (i.e., the elements), their families and the starting point are needed by the <o>cage.lumbricus</o> engine to make its work; the allowed pitches and the desired melodic profile are not: instead, these data are needed by the section of the patch in charge of evaluating the rules, that is the lambda loop.</body>


<subhead>The patch</subhead>

<body>Now that we know what our patch is meant to do, let's sketch its general architecture. We'll need to be able to define the intervals, the allowed notes and the starting point or points. Each of these data can be conveniently represented into a <o>bach.roll</o> object: so, at the top of the patch there will be a handful of small <o>bach.roll</o>s to contain all this stuff. The "intervals" <o>bach.roll</o>s will not contain actual intervals, but rather melodic snippets that we'll consider freely transposable - which means, after all, that we're interested only in their intervallic structure. For each "intervals" roll, we'll also need some sort of slider to represent its weight. We'll need a section of the patch to take the melodic snippets, extract their intervallic sequences, build its transformations if needed (yes, we'll also need some toggles to choose which transformations we want) and structure it all into families - in fact, we'll do it the other way around but that's the idea. Then we'll need to properly display the obtained sequence into another <o>bach.roll</o>, but that must be easy.</body>

<body>And finally we need the patch in the lambda loop, which will receive the data from the lambda inlet but also the other initialization data, that is the allowed notes (so that for each note resulting from a tested intervallic cell we can tell if it's acceptable or not) and the melodic profile in form of a breakpoint function (so that we can assign a score to each acceptable cell, according to how close it would match the profile at the current position in the sequence). We also need to pass to the lambda patch the intended number of notes, which in general will be higher than the number of elements, since each element can potentially translate to several notes in the sequence: for this reason, the process will be stopped from within the lambda loop via a <m>break</m> message, rather than end naturally when the requested number of elements has been inserted.</body>

<body>Let's look at the patch now.</body>

<body>You can probably recognize the elements we hinted at above. We have six small <o>bach.roll</o> objects containing the melodic snippets, and six <o>live.slider</o>s with the weights. We have two larger rolls, a light blue one with the allowed notes and a green one with the starting point. We have a <o>function</o> object containing a W-shaped function. We have three toggles for the inversions, permutations and retrogrades. We have <o>cage.lumbricus</o> with a patch in its lambda loop. We have a quite large roll at the bottom of the patch, presumably to collect the resulting sequence. And we have a big red <o>button</o>, presumably to start the process. Before starting the process, you should check to have Overdrive on, in Max's Options menu. If you don't, the process will work all the same but you won't be able to see the sequence being built - which, by some nerdy standards, can be quite fun. Ok, now let's click the red <o>button</o>. Yay, it works! You should be able to distinguish the roughly W-shaped melodic profile in the sequence displayed in the large <o>bach.roll</o>: and if you really want to check the correctness of the sequence with respect to the requests, you will see that it is indeed correct.</body>

<body>After all this, discuss some of the details of how the patch is implemented should be relatively easy. You are encouraged to put some <o>bach.print</o> objects around and repeat the process, to see what happens at different points of the patch.</body>

<body>The "prepare families" subpatch is quite simple: it receives all the rolls and the weights; it removes some unnecessary parentheses from the rolls. It restructures the incoming data to the form <b>((NOTE NOTE ...) WEIGHT) ((NOTE NOTE...) WEIGHT) ...</b>. And finally it removes families whose only element is an empty list, or - by accident - a list containing a single note, by cheating just a tiny bit with the lambda syntax of <o>bach.sieve</o> (remember that all this will be used to define intervals, so we need at least two notes): if the second note of each family sublist exists, then its length will be 1 and the sublist will be accepted by <o>bach.sieve</o>, otherwise the length will be 0 and the sublist will be rejected.</body>

<body>The llll with the families goes to the "prepare cells" subpatch, which implements a main loop, through the lambda loop of <o>bach.mapelem</o>, to apply the requested transformations to all the families (which, at this point, still contain one cell each). You may want to have a look at the somewhat tricky combination of <o>expr</o> and <o>minimum</o> driving the gate, but that's just commodity stuff: the idea is that, since the retrograde is actually a permutation, it will never be necessary to compute both of them. On the other hand, if the inversion has to be computed, it will have to be computed on the permutations or the retrogrades as well (provided that they are requested): hence the <o>bach.mapelem</o> object in charge of applying the permutations to the single cells of each family; more importantly, the patch "conversion to intervals and maybe inversion" also replaces every melodic snippet with its intervallic structure, using the <o>bach.x2dx</o> abstraction. At the end of the lambda loop of the outer <o>bach.mapelem</o>, if there are duplicated cells (which may happen: for example, the retrograde and the inversion of a single interval are the same!) they are removed. This subpatch outputs the actual families that will be processed by <o>cage.lumbricus</o>.</body>

<body>The third inlet of <o>cage.lumbricus</o> receives the number of elements to compute. For the sake of simplicity, here we use the number of intended notes: but, as we said above, there will always be at least one more note than intervallic cells, and since the computation is interrupted when the number of intended notes is reached, the number of elements never is: which is a handy way to ensure that we'll always request enough elements!</body>

<body>Let's have a quick look at the "starting points" patch. The workings of this patch are activated when the green <o>bach.roll</o> sends out its data, which in turn happens - along with some other trivial initialization tasks - when you click on the big red <o>button</o> on the top. Now three scenarios are possible: first, the green <o>bach.roll</o> contains a single note; that's easy: this note is the only starting point. Second, it contains more than one note: if <o>cage.lumbricus</o> receives more than one starting point, it will try to build a sequence starting from the first, if it can't it will try with the second, and so on. Here, in order to add some unpredictability, the list of the starting points is randomly permuted by <o>bach.scramble</o> at every new computation. Third, the green <o>bach.roll</o> is empty. In this case, <o>bach.filternull</o> will fire a <m>bang</m> from its right inlet, and the bang will cause <o>bach.reg</o> to output its contents, that is the notes of the blue <o>bach.roll</o>, so that all the set of the allowed notes is scrambled and used as a multiple starting point. As soon as <o>cage.lumbricus</o> receives the starting points in its first inlets, the search begins!</body>

<body>Now it's time to open the blue patch named "evaluation and substitution". Here is where the bulk of the work gets done. Let's see what happens when an llll output by the lambda outlet of <o>cage.lumbricus</o> enters the first inlet of this patch. Firstly, its third element (that is, the sequence built so far) is extracted, and sent to the green patch cord. The length of the sequence is then checked, and if it has reached the intended number of notes the <m>break</m> message is dispatched to <o>cage.lumbricus</o>; otherwise, we ask the <o>function</o> object, which contains a copy of the function drawn in the main patch, to tell us at which height we should be now. Then, the sequence built so far is sent to the right outlet of the patch, to be displayed in the yellow <o>bach.roll</o>, and then its last note is extracted, to be used to calculate the subsequent notes that would become part of the sequence if this intervallic cell is chosen - but we'll return to this later.</body>

<body>Then, the first element of the llll coming from <o>bach.lumbricus</o> is extracted - it contains the proposed cell to be evaluated, that is an intervallic sequence. First we have a small digression: a random number between -0.1 and 0.1, but with the exception of 0, is computed and stored in the middle inlet of the brown <o>bach.join</o>, so as to add some unpredictability to the sequence (we'll see shortly how). Then, the intervallic cell is converted to a melodic snippet, that is notes, starting from the current last note of the sequence which was stored in the red <o>bach.reg</o>, by <o>bach.dx2x</o>. These notes are first evaluated for their closeness to the current point of the melodic profile function: the formula in the purple <o>bach.expr</o> object means "the smaller the distance, the higher the score" - notice that everything is normalized in the 0-1 range. This values, one for each note, are stored in the brown <o>bach.join</o> too. Now, we check if all the notes in the sequence are allowed: if they are, <o>bach.belong</o> returns 1, otherwise 0. This value is multiplied together with the others that were stored in the brown <o>bach.join</o>: the result will be 0 if there were non-allowed notes, or a score determined by the adherence to the profile and the random number extracted before if all the notes were allowed. This is the score that we will pass back to <o>cage.lumbricus</o>. Finally, the first note of the melodic snippet is removed, because it was already the last element of the sequence built so far and we don't want to repeat it twice; and the beheaded snippet and the score are sent back to the lambda inlet of <o>cage.lombricus</o>.</body>

<body>Indeed, a more efficient implementation of this evaluation would first check if the intervallic cell produces allowed notes, and only in this case it would perform all the other calculations. But this would require some extra complexity in the patch, and on the other hand optimizing this version can be an excellent patching exercice!</body>

<body>Anyway, all this process is performed for every cell in the domain at every step in the construction of the sequence: after all the cells for one step have been given a score, <o>cage.lombricus</o> weights this score with the statistical distributions of the cells in the sequence, picks the best match and puts it in the sequence. If at some point all the cells have a score of 0, it goes back to the previous element of the sequence, changes it to the second-best and tries to find an usable cell; and so on, until a solution is found, or all the possibilities have been explored and no solution has been found. This ensures that, provided that the lambda patch is correctly written, if a solution exists it will be eventually found; but if more than one solution exist, there is no warranty that the best possible solution is the one that will be returned: this happens because the <o>cage.lumbricus</o> algorithm is greedy, that is it always choose the path that locally offers the highest score, without worrying whether this will bring to an optimal solution in the long term. It's like climbing a mountain always choosing the steepest possible step: it sure will bring you up, but you might never reach the highest peak. On the other hand, greedy algorithms have the advantage of being potentially extremely fast when compared to more accurate ones: the exact same problem might probably be stated in the much more theoretically solid <o>bach.constraints</o>, but a solution would most likely never be found before the sun expands and engulfs the Earth, 5 billion years from now. Not to mention that your computer might break in the meantime.</body>

<body>So, let's finish this overview of this menial, but ultimately practical patch: if the intervallic cells, the allowed notes and the starting notes are chosen consistently with each other, in a matter of some tenths of seconds at the most a solution should be found - meaning that the blue patch sends the <m>break</m> message to <o>cage.lumbricus</o>. The solution is then output, in the form of an llll composed of sublists, each containing a beheaded melodic snippet. All we have to do now is re-formatting the list, and send it to our yellow <o>bach.roll</o> along with some velocity and temporal data to make it not too unpleasant to hear.</body>



<subhead>Conclusion</subhead>

<body>We saw how a quite advanced musical problem can be relatively easily solved by <o>cage.lombricus</o>. Indeed, this abstraction lends itself to a variety of other musically interesting processes, based upon a principle of construction of sequences driven by rules.</body>

<seealsolist>
<seealso name="bach.constraints">Solve constraint satisfaction problems</seealso>
<seealso name="cage.chain">Generate L-systems</seealso>
<seealso name="cage.life">Drive the evolution of cellular automata</seealso>
</seealsolist>

</chapter>