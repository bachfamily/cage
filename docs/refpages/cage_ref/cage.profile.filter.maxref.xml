<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<?xml-stylesheet href="./_c74_ref.xsl" type="text/xsl"?>

<!--This file has been automatically generated by Doctor Max. DO NOT EDIT THIS FILE DIRECTLY.-->

<c74object name="cage.profile.filter" module="cage" kind="patcher">

	<digest>
		Filter pitch profiles
	</digest>

	<description>
		Applies a given filter to a llll of pitches.
	</description>

	<!--METADATA-->
	<metadatalist>
		<metadata name="author">cageproject</metadata>
		<metadata name="tag">cage</metadata>
		<metadata name="tag">cage profiles</metadata>
	</metadatalist>

	<!--INLETS-->
	<inletlist>
		<inlet id="0" type="INLET_TYPE">
			<digest>
				Original cents
			</digest>
			<description>
			</description>
		</inlet>
		<inlet id="1" type="INLET_TYPE">
			<digest>
				Filter type, window size and iteration order
			</digest>
			<description>
			</description>
		</inlet>
		<inlet id="2" type="INLET_TYPE">
			<digest>
				Lambda inlet
			</digest>
			<description>
				A lambda inlet is an inlet receiving the answer from a test or modification performed on elements sent out the lambda outlets. <br />
				In this case, the answer is expected to be a modification of the elements which had been sent out:
				the element output via the lambda outlet can be customly modified and then plugged in into this lambda inlet:
				such modification will be accounted for by the algorithm. <br />
				The lambda inlet also accepts the result in llll form, so you can sometimes avoid the explicit @out t. <br />
				It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
				<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
				<br /> <br />
			</description>
		</inlet>
	</inletlist>

	<!--OUTLETS-->
	<outletlist>
		<outlet id="0" type="INLET_TYPE">
			<digest>
				Output cents
			</digest>
			<description>
			</description>
		</outlet>
		<outlet id="1" type="INLET_TYPE">
			<digest>
				Lambda outlet
			</digest>
			<description>
				Outputs the groups of pitches for a custom filter
				(see <m>list</m>).
				A lambda outlet is an outlet outputting an element on which some test or modification must be performed.
				The result of the test or modification is then expected in a lambda inlet. <br />
				In this case, the elements output from the lambda outlet may be customly modified, so that such modification will be taken into
				account by the algorithm. To modify each element, just use patching and then plug into the lambda inlet the
				modified version of the element. <br />
				It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
				<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
				<br /> <br />
			</description>
		</outlet>
	</outletlist>

	<!--ARGUMENTS-->
	<objarglist>
		<objarg name="filter" optional="1" type="list">
			<digest>
				Filter type, window size and iteration order
			</digest>
			<description>
				The optional arguments set the filter type, window size and iteration order
				(see <m>list</m>).
			</description>
		</objarg>
	</objarglist>

	<!--MESSAGES-->
	<methodlist>
		<method name="bang">
			<arglist />
			<digest>
				Output result
			</digest>
			<description>
				Output the pitch profile obtained from the most recently received input data.
			</description>
		</method>
		<method name="float">
			<arglist />
			<digest>
				Lambda inlet
			</digest>
			<description>
				A <m>float</m> in the third inlet is the result of
				the evaluation of a lambda loop, and contains the modified pitch
				corresponding to the output window of pitches.
				A lambda inlet is an inlet receiving the answer from a test or modification performed on elements sent out the lambda outlets. <br />
				In this case, the answer is expected to be a modification of the elements which had been sent out:
				the element output via the lambda outlet can be customly modified and then plugged in into this lambda inlet:
				such modification will be accounted for by the algorithm. <br />
				The lambda inlet also accepts the result in llll form, so you can sometimes avoid the explicit @out t. <br />
				It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
				<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
				<br /> <br />
			</description>
		</method>
		<method name="list">
			<arglist />
			<digest>
				Set filter type, window size and iteration order
			</digest>
			<description>
				A <m>list</m> in the second inlet sets the type
				and the parameters of the filter, with the following syntax:
				<b><m>filter_name</m> <m>window_size</m> <m>iteration_order</m></b>.
				Filter name is a symbol which can either be: <b>average</b> or
				<b>median</b> or <b>custom</b>.
				Window size (default: 2) is the number of pitches on which the filter
				function is applied. For instance, if this is 3, for a median filter,
				this means that the median is taken for each (overlapping) group of
				3 pitches.
				The iteration order (default: 1) is the number of times the
				whole process is repeated. If this is 2, for instance, this means
				that the whole pitch profile is filtered once, and then filtered
				again another time.
				If the filter is of type <b>custom</b>, groups of <m>window_size</m>
				original notes are output one after another from the second (lambda)
				outlet. The user can modify the result by patching and plug
				it into the third (lambda) inlet.
			</description>
		</method>
		<method name="llll">
			<arglist />
			<digest>
				Set pitches, output result
			</digest>
			<description>
				An incoming llll is expected to contain the pitches
				which have to be filtered.
				Each pitch is filtered according to the selected filter, and the
				modified llll is output. <br />
				An llll in second inlet is converted into a <m>list</m>. <br />
				An llll in third (lambda) inlet is converted into a <m>float</m>.
			</description>
		</method>
	</methodlist>

	<!--ATTRIBUTES-->
	<attributelist>
		<attribute name="out" get="1" set="1" type="symbol" size="1">
			<digest>
				Outlet Types
			</digest>
			<description>
				The <m>out</m> attribute is a sequence of characters identifying the outlet types (one character for each llll outlet). Characters can be one of the following: <br />
				<m>n</m> (default): 'native' output: faster and more precise between bach objects, but unreadable by standard Max objects (an "bach.llll" message appears instead). <br />
				<m>t</m>: 'text' output: slower and limited in size, but readable by standard Max objects. A plain llll in text format is a generic Max message.
				To keep the representation invertible (i.e., to allow a bach object receiving a text-format llll to interpret it exactly as if it was native format,
				except for the size limitation), some specific kinds of symbols are preceded by a backtick: namely, symbols containing parens, or containing textual
				representations of numbers or pitches, or beginning with a backtick, plus the symbols "null" and "nil" (distinct from the reserved words
				"null" and "nil" representing the empty list and the empty sublist) are preceded by a backtick. Moreover, the symbols "int", "float" or "list"
				are preceded by a backtick only if they are the first element of an llll, to distinguish them from the corresponding reserved messages of Max. <br />
				<m>m</m>: 'max' output: mostly equivalent to the <t> specifier, but no symbol is backticket except "int", "float" and "list" at the beginning of an llll.
				It is important to notice that, differently from text-format lllls proper, Max-format lllls might not be invertible even if they do not reach the size
				limit for Max message. This means that a bach object receiving a Max-format llll output from another bach object might interpret it differently
				from the original, or in some cases might even reject it. <br />
				<m>x</m>: disabled output (nothing is output) <br />
				<m>p</m>: 'portal' output: only used by bach.portal to intercept the @out attribute specified while creating the abstraction (see bach.portal). <br />
				The native output is recommended, unless communication with standard Max messages is needed.
				Disabling unused outputs can be useful if extreme optimization of the patch is needed.
				<br /> <br />
			</description>
			<attributelist>
				<attribute name="category" get="1" set="1" type="symbol" size="1" value="Behavior" />
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Outlet Types" />
				<attribute name="save" get="1" set="1" type="int" size="1" value="1" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
	</attributelist>

	<!--DISCUSSION-->
	<discussion>
		Preset filters are: an average filter and a median filter.
		A custom filter is also possible via a lambda loop.
		A certain number of bach objects are equipped with "lambda" inlets and outlets. These inlets and outlets -
		always the rightmost ones - serve the purpose of letting you define a function the object will base its behavior upon.
		Such function is indeed a patching loop: parameters are taken from the lambda outlet(s), processed, and the "result" is
		plugged in the lambda inlet(s). The type of function, and the corresponding expected result, depend on the object behavior;
		for instance, cycles modifying elements will expect as "result" the modified element; cycles testing for custom equalities will
		expect a 0/1 answer (0 meaning: not equal; 1 meaning: equal), as well as cycles testing custom inequalities and sorting (1 meaning: the two
		elements are in the correct order; 0 meaning: the order is wrong). Refer to each specific object to know more about it.
		With many objects, it is not mandatory to provide an evaluation cycle: if you don't, a default function will be used. <br />
		It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
		<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
		<br /> <br />
	</discussion>

	<!--SEEALSO-->
	<seealsolist>
		<seealso name="cage.profile.gen" />
		<seealso name="cage.profile.mirror" />
		<seealso name="cage.profile.perturb" />
		<seealso name="cage.profile.rectify" />
		<seealso name="cage.profile.snap" />
		<seealso name="cage.profile.stretch" />
	</seealsolist>

	<misc name = "Input">
		<entry name ="Inlet 1 (llll)">
			<description>
				Original cents.
			</description>
		</entry>
		<entry name ="Inlet 2 (list/llll)">
			<description>
				Filter type, window size and iteration order.
			</description>
		</entry>
		<entry name ="Inlet 3 (float/llll)">
			<description>
				Lambda inlet.
				A lambda inlet is an inlet receiving the answer from a test or modification performed on elements sent out the lambda outlets. <br />
				In this case, the answer is expected to be a modification of the elements which had been sent out:
				the element output via the lambda outlet can be customly modified and then plugged in into this lambda inlet:
				such modification will be accounted for by the algorithm. <br />
				The lambda inlet also accepts the result in llll form, so you can sometimes avoid the explicit @out t. <br />
				It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
				<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
				<br /> <br />
			</description>
		</entry>
	</misc>

	<misc name = "Output">
		<entry name ="Outlet 1 (llll)">
			<description>
				Output cents.
			</description>
		</entry>
		<entry name ="Outlet 2 (llll)">
			<description>
				Lambda outlet.
				Outputs the groups of pitches for a custom filter
				(see <m>list</m>).
				A lambda outlet is an outlet outputting an element on which some test or modification must be performed.
				The result of the test or modification is then expected in a lambda inlet. <br />
				In this case, the elements output from the lambda outlet may be customly modified, so that such modification will be taken into
				account by the algorithm. To modify each element, just use patching and then plug into the lambda inlet the
				modified version of the element. <br />
				It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
				<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
				<br /> <br />
			</description>
		</entry>
	</misc>

	<misc name = "Discussion">
		<entry name ="More details">
			<description>
		Preset filters are: an average filter and a median filter.
		A custom filter is also possible via a lambda loop.
		A certain number of bach objects are equipped with "lambda" inlets and outlets. These inlets and outlets -
		always the rightmost ones - serve the purpose of letting you define a function the object will base its behavior upon.
		Such function is indeed a patching loop: parameters are taken from the lambda outlet(s), processed, and the "result" is
		plugged in the lambda inlet(s). The type of function, and the corresponding expected result, depend on the object behavior;
		for instance, cycles modifying elements will expect as "result" the modified element; cycles testing for custom equalities will
		expect a 0/1 answer (0 meaning: not equal; 1 meaning: equal), as well as cycles testing custom inequalities and sorting (1 meaning: the two
		elements are in the correct order; 0 meaning: the order is wrong). Refer to each specific object to know more about it.
		With many objects, it is not mandatory to provide an evaluation cycle: if you don't, a default function will be used. <br />
		It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
		<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
		<br /> <br />
			</description>
		</entry>
		<entry name ="Keywords">
			<description>
profile, filter, apply, melody, pitch.
			</description>
		</entry>
	</misc>

</c74object>